[{"title":"使用commitlint、eslint规范项目代码","date":"2019-02-13T10:18:59.000Z","path":"2019/02/13/front-eslint/","text":"在项目中使用commitlint 安装commitlint 123yarn add @commitlint/cli --devyarn add @commitlint/config-conventional --devyarn add husky --dev 编辑项目package.json，增加提交代码钩子 12345\"husky\": &#123; \"hooks\": &#123; \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\" &#125;&#125; 在项目根目录增加commitlint.config.js，内容如下： 使用Conventional Commits校验规则： 1module.exports = &#123; extends: ['@commitlint/config-conventional'] &#125;; 在项目中使用eslint 安装eslint 123456yarn add eslint --devyarn add babel-eslint --devyarn add eslint-config-airbnb --devyarn add eslint-plugin-import --devyarn add eslint-plugin-react --devyarn add eslint-plugin-jsx-a11y --dev 编辑项目package.json，增加提交代码钩子 12345\"husky\": &#123; \"hooks\": &#123; \"pre-commit\": \"npm run lint\", &#125;&#125; 在项目根目录增加.eslintrc，内容如下（可根据自己需求调整）： 具体配置可参考ESLint官网 12345678910111213141516171819202122232425262728module.exports = &#123; \"parser\": \"babel-eslint\", \"parserOptions\": &#123; \"ecmaVersion\": 7, \"sourceType\": \"module\", \"ecmaFeatures\": &#123; \"jsx\": true &#125; &#125;, \"env\": &#123; \"es6\": true, \"node\": true, \"browser\": true, &#125;, \"globals\": &#123; \"document\": true, \"navigator\": true, \"window\": true, \"node\": true, \"__DEV__\": true, &#125;, \"extends\": \"airbnb\", \"plugins\": [ \"react\", \"jsx-a11y\", \"import\" ]&#125;;","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"React Native修改APP名称及图标","date":"2019-02-12T09:06:32.000Z","path":"2019/02/12/front-rn-app-icon/","text":"生成图标通过图标工场, 在线生成所有尺寸的应用图标，下载并解压 Android修改APP名称编辑项目文件：android/app/src/main/res/values/strings.xml，修改app_name 123&lt;resources&gt; &lt;string name=\"app_name\"&gt;熊猫陈皮&lt;/string&gt;&lt;/resources&gt; Android修改APP图标使用生成的图标覆盖android/app/src/main/res中的图标目录 1234567- res-- mipmap-hdpi-- mipmap-ldpi-- mipmap-mdpi-- mipmap-xhdpi-- mipmap-xxhdpi-- mipmap-xxxhdpi IOS修改APP名称编加项目文件：ios/{应用目录}/Info.plist，修改CFBundleDisplayName 12&lt;key&gt;CFBundleDisplayName&lt;/key&gt;&lt;string&gt;熊猫陈皮&lt;/string&gt; IOS修改APP图标使用生成的图标覆盖ios/{应用目录}/Images.xcassets中的图标目录","tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.smallpig.cn/tags/前端框架/"}]},{"title":"创建&发布npm包","date":"2018-12-30T04:03:00.000Z","path":"2018/12/30/front-npm-publish/","text":"官网创建npm帐号点击 注册 命令行工具登录 npm login 12345firewood-lv:~ firewood$ npm loginUsername: testPassword:Email: (this IS public) xxx@yyy.comLogged in as test on https://registry.npmjs.org/. 验证是否登录成功；npm whoami 12firewood-lv:~ firewood$ npm whoami test 创建npm包 npm init 按提示输入相应内容，以下为package.json样例 1234567891011121314151617181920212223242526272829303132333435363738&#123; \"name\": \"@plutojs/node-markdown-docs\", \"version\": \"1.0.5\", \"description\": \"add markdown docs for node.js project\", \"main\": \"./bin/index.js\", \"publishConfig\": &#123; \"access\": \"public\" &#125;, \"scripts\": &#123; \"test\": \"node ./bin/index.js start\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git@github.com:firewood1122/node-markdown-docs.git\" &#125;, \"keywords\": [ \"markdown\" ], \"engines\": &#123; \"node\": \"&gt;= 8.11.2\", \"npm\": \"&gt;= 5.6.0\" &#125;, \"author\": \"firewood.lv\", \"license\": \"ISC\", \"dependencies\": &#123; \"commander\": \"^2.19.0\", \"consola\": \"^2.2.3\", \"ejs\": \"^2.6.1\", \"express\": \"^4.16.4\", \"markdown-it\": \"^8.4.2\", \"opn\": \"^5.4.0\", \"semver\": \"^5.6.0\", \"shelljs\": \"^0.8.3\" &#125;, \"bin\": &#123; \"md-server\": \"./bin/index.js\" &#125;&#125; 发布npm包 npm publish 作废指定包的指定版本1npm deprecate @plutojs/node-markdown-docs@1.0.4 \"critical bug fixed in v1.0.5\" 查看npm官网版本： 注意事项 发布时必须使用官方npm源，使用其他npm源会报错 package.json中registory属性必须填写，每次npm publish时version版本一定要大于上一次 npm包的name是唯一的，如果有同名，发布时会报错 参考文档 https://www.npmjs.cn/","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"使用log4js记录nodejs服务日志","date":"2018-10-15T11:54:59.000Z","path":"2018/10/15/server-log4js/","text":"简介log4js 是一个 nodejs 日志管理工具，可以将日志以各种形式输出到各种渠道可以通过npm安装：npm install log4js 日志级别实际应用中，日志是按级别进行记录的，首先我们来了解一下log4js的日志级别都有哪些？ trace：指定粒度比debug更低的信息事件 debug：指定细粒度信息事件，用于应用调试 info：指定能够突出在粗粒度级别的应用程序运行情况的信息 warn：指定具有潜在危害的情况 error：指定错误事件，可能仍然允许应用程序继续运行 fatal：指定非常严重的错误事件，可能导致应用程序中止 对照上图，我们可以在代码中引用对应日志级别：12345678let levels = &#123; trace: log4js.levels.TRACE.levelStr, debug: log4js.levels.DEBUG.levelStr, info: log4js.levels.INFO.levelStr, warn: log4js.levels.WARN.levelStr, error: log4js.levels.ERROR.levelStr, fatal: log4js.levels.FATAL.levelStr&#125;; 建议主要使用debug、info、warn、error 日志配置定义日志格式1234let layout = &#123; type: 'pattern', pattern: '[%d&#123;yyyy-MM-dd hh:mm:ss.SSS&#125;] [%p] [%z] [%c&#123;50&#125;] &gt;&gt;&gt; [%c] json=&#123;&#125; msg=%m%n'&#125;; 具体格式可以参考： %r time in toLocaleTimeString format %p log level %c log category %h hostname %m log data %d date, formatted - default is ISO8601, format options are: ISO8601, ISO8601_WITH_TZ_OFFSET, ABSOLUTE, DATE, or any string compatible with the date-format library. e.g. %d{DATE}, %d{yyyy/MM/dd-hh.mm.ss} %% % - for when you want a literal % in your output %n newline %z process id (from process.pid) %x{} add dynamic tokens to your log. Tokens are specified in the tokens parameter. %X{} add values from the Logger context. Tokens are keys into the context values. %[ start a coloured block (colour will be taken from the log level, similar to colouredLayout) %] end a coloured block 定义日志分类及输出方式123456789101112131415161718192021222324252627282930313233343536let appenders = process.env.NODE_ENV == 'production' ? ['default'] : ['console'];log4js.configure(&#123; appenders: &#123; default: &#123; type: 'dateFile', filename: config.logPath, pattern: 'yyyy-MM-dd.log', alwaysIncludePattern: true, layout: layout &#125;, console: &#123; type: 'console', layout: layout &#125; &#125;, categories: &#123; default: &#123; appenders: appenders, level: levels.info &#125;, console: &#123; appenders: appenders, level: process.env.NODE_ENV == 'production' ? levels.warn : levels.info &#125; &#125;, pm2: true&#125;);const logger = log4js.getLogger('console');console.log = logger.info.bind(logger);module.exports.getLogger = function(name) &#123; let logger = log4js.getLogger(name || 'default'); logger.level = levels.info; return logger;&#125;; appenders定义不同的日志输出方式，以上例子中，该服务的日志会聚合成一个文件，按天进行切分 通过环境变量控制不同的日志记录逻辑：开发环境，console.log内容会通过控制台打印；生产环境，console.log内容不会记录 通过日志级别控制日志输出：生产环境，info级别以下日志不会记录 如何打印日志记录日志123let log4js = require('./log').getLogger()log4js.info('INFO MSG')log4js.error('ERROR MSG') express路由逻辑中，使用next统一拦截错误123456789101112module.exports = (req, res, next) =&gt; &#123; try &#123; ... &#125; catch(err) &#123; next(error); &#125;&#125;app.use(function(err, req, res, next) &#123; log4js.error(err); ...&#125;); 对未处理错误统一捕获123process.on('uncaughtException', function(err) &#123; log4js.error(err);&#125;); 配合PM2使用如果要配合PM2使用，必须安装依赖包：pm2-intercom，如果不安装，会导致日志丢失 1pm2 install pm2-intercom 注意事项 打印日志需有效可用，日志量过大不利于分析利用，同时也影响系统性能 同步代码错误会自动捕获，异步代码必须进行主动捕获（如try…catch…，Promise的catch），否则错误系统可能会丢失堆栈信息 参考文档 https://log4js-node.github.io/log4js-node/ https://github.com/log4js-node/log4js-node/blob/dcdf2ad1cc3db47713c3a98a26819a99db8a7344/docs/clustering.md","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"通过Docker Machine运行docker容器","date":"2017-07-18T10:53:08.000Z","path":"2017/07/18/server-docker-machine/","text":"Docker Machine原理 Docker Machine使用boot2docker作为虚拟机的镜像 boot2docker是一个运行Docker容器的轻量级Linux系统，完全在内存中运行 boot2docker用户/密码 用户 密码 进入方式 docker tcuser ssh root command：sudo -i (docker用户下执行) 修改安装的machine目录设置MACHINE_STORAGE_PATH环境变量为指定machine目录 获取Docker加速器地址 注册登陆 阿里云-Docker镜像仓库 点击 Docker Hub 镜像站点，在页面找到您的专属加速器地址 创建一台安装有Docker环境的Linux虚拟机，指定机器名称为default，同时配置Docker加速器地址1docker-machine create --engine-registry-mirror=https://xxx.mirror.aliyuncs.com -d virtualbox default 查看docker-machine信息1docker-machine env default Windows 7 挂载共享目录 设置 VirtualBox 中 docker 用的虚拟机的共享文件夹 填写共享文件夹路径和名称，如：E:\\ 共享文件夹名称: e 勾选自动挂载和固定分配 重启 进入虚拟机，找到 /e 这个目录，目录中的文件就是 win7 中 E:\\ 共享文件夹 中的文件 查看docker信息1docker version 拉取Docker镜像可以在 官方镜像站点 查找合适的镜像，然后拉取下来：1docker pull centos 交互式进入容器1docker run -it default /bin/bash 挂载数据卷挂载 /e/folder 到Docker容器中的 /folder 目录：1docker run -it -v /e/folder:/folder default /bin/bash 配置端口映射映射Docker容器中的8089端口到宿主机的8089端口：1docker run -p :8089:8089 default 停用全部运行中的容器1docker stop $(docker ps -q) 删除全部容器1docker rm $(docker ps -aq) webpack在Docker容器中的坑尝试在Docker容器中进行开发工作，但遇到Docker容器对热更新的坑：webpack watch in vagrant docker 参考文档 https://docs.docker.com/machine/ http://www.docker.org.cn","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"Linux下添加新分区及挂载","date":"2017-06-15T06:55:17.000Z","path":"2017/06/15/server-linux-fdisk/","text":"主分区、扩展分区、逻辑分区的区别 主分区：包含操作系统启动所必需的文件和数据的硬盘分区，如需在硬盘上安装操作系统，该硬盘必须得有一个主分区 扩展分区：除主分区外的分区，不能直接使用，必须再划分为若干个逻辑分区 不管使用哪种分区软件，新硬盘上建立分区时都要遵循以下的顺序：建立主分区-&gt;建立扩展分区-&gt;建立逻辑分区-&gt;激活主分区-&gt;格式化所有分区 添加分区步骤如下： 挂载新硬盘后，输入fdisk -l命令查看当前磁盘信息 输入fdisk /dev/sdb命令进行分区 进入fdisk命令，输入h可以查看该命令的帮助，按n进行分区 输入e则分为逻辑分区，输入p则分为主分区，该盘分为主分区输入p 输入该主分区为第几个主分区，由于是新盘，输入1来分第一个主分区 First Cylinder是选择该分区的起始磁盘数，可自定义也可不做选择，默认是1，如无特殊需求强烈建议选择默认 定义该分区的大小，按默认即是使用全部可用存储额，也可以是用M或m单位结尾的数字 输入w写入分区，等待结束 输入fdisk -l，可以看到分的一个分区，继续输入mkfs -t ext3 -c /dev/sdb1进行格式化 分区完成后，使用mount挂载该分区即可使用，这里挂载到mnt目录下，也可以自建一个目录挂载 使用df -TH命令查看当前挂载的分区和大小 如系统重启需自动挂载该分区，可修改/etc/fstab文件，在最后加上：/dev/sdb1 /www ext3 defaults 1 2 12345/dev/sdb1：分区名称ext3：分区的格式defaults：挂载时所要设定的参数(只读，读写，启用quota等)1：使用dump是否要记录，0是不要2：开机时检查的顺序，boot系统文件为1，其他文件系统为2，如不要检查为0","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"Docker简介","date":"2017-06-02T01:54:06.000Z","path":"2017/06/02/server-docker-start/","text":"什么是Docker？Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器开发者在本地机器上编译测试通过的容器可以批量的在生产环境中部署 Docker使用场景 web应用的自动化打包、发布 自动化测试和持续集成、发布 在服务器环境中部署、调整数据库/后台应用 从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境 Docker在开发和运维中的优势 更快速的交付和部署：开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成后，测试和运维人员可以直接使用相同环境来部署代码；Docker可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间；各个步骤都有明确的配置和操作，整个过程全程可见，使团队更容易理解应用的创建和工作过程 更高效的资源利用：Docker容器的运行不需要额外的虚拟化管理程序（Virtual Machine Manager，VMM，以及Hypervisor）支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低 更轻松的迁移和扩展：Docker容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，这种兼容性让用户可以在不同平台之间轻松地迁移应用 更简单的更新管理：使用Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作，所有修改都以增量的方式进行分发和更新，从而实现自动化和高效的容器管理 Docker与虚拟机比较 Docker容器很快，启动和停止可以在秒级实现，相比传统的虚拟机方式要快得多 Docker容器对系统资源需求很少，一台主机上可以同时运行数千个Docker容器 Docker通过类似Git的操作来方便用户获取、分发和更新应用镜像，指令简明，学习成本较低 Docker通过Dockerfile配置文件来支持灵活的自动化创建和部署机制，提高工作效率 Docker容器除了运行其中的应用之外，基本不消耗额外的系统资源，保证应用性能的同时，尽量减小系统开销；传统虚拟机方式运行N个不同的应用需要启动N个虚拟机（每个虚拟机需要单独分配独占的内存、磁盘等资源），而Docker只需要启动N个隔离的容器，将应用放到容器内即可 隔离性方面：传统的虚拟机方式多了一层额外的隔离，这并不意味着Docker就不安全，Docker利用Linux系统上的多种防护机制实现了严格可靠的隔离 什么是Docker Machine？Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure Docker Machine的出现解决了以下问题： 简化了部署的复杂度，无论是在本机的虚拟机上还是在公有云平台，只需要一条命令便可搭建好Docker主机 提供了多平台多Docker主机的集中管理 使应用由本地迁移到云端变得简单，只需要修改一下环境变量即可和任意Docker主机通信部署应用","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"研发流程中的项目管理&分支管理","date":"2017-05-23T07:50:53.000Z","path":"2017/05/23/job-project-manage/","text":"工具简介工欲善其事，必先利其器，以下是我们在项目管理中经常使用的工具： 工具 简介 官方链接 Confluence 专业的企业知识管理软件，可以用于构建企业wiki Confluence jira Atlassian公司出品的项目与事务跟踪工具 jira Bugzilla 开源的缺陷跟踪系统（Bug-Tracking System） Bugzilla GitLab 开源的版本管理系统 GitLab 项目管理 产品需求，研发设计，测试用例设计三者不是绝对的前后顺序流程，更多的时候是在项目过程中以小循环的模式在流转： 下表是整个项目流程中，涉及的参与人员与对应的工具使用： 流程节点 参与人员 使用工具 产品需求 产品，业务方 Confluence：需求文档 需求评审 产品，研发，测试 研发设计 研发 Confluence：设计文档；jira：任务管理 设计评审 产品，研发，测试 编码开发 研发 jira：任务管理；GitLab：代码版本管理 测试用例设计 测试 Confluence：测试用例 用例评审 产品，研发，测试 研发自测 研发 测试 产品，研发，测试 Bugzilla：bug跟踪 部署设计 研发，运维，测试 Confluence：部署文档 部署设计评审 研发，运维，测试 产品/业务验收 产品，业务方 上线 产品，研发，测试，运维，业务方 分支管理 参考文档 http://blog.smallpig.cn/2016/10/10/server-git-base/","tags":[{"name":"工作心得","slug":"工作心得","permalink":"http://blog.smallpig.cn/tags/工作心得/"}]},{"title":"浅析HTTP协议","date":"2017-02-15T08:41:18.000Z","path":"2017/02/15/server-http/","text":"待续…","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"Chome浏览器Timeline工具的使用","date":"2017-02-13T01:45:05.000Z","path":"2017/02/13/front-chrome-timeline/","text":"待续…","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"WEBKIT渲染原理","date":"2017-01-24T01:07:29.000Z","path":"2017/01/24/front-dramatize-base/","text":"从网页URL到生成DOM树 用户输入url，webkit调用资源加载器加载对应页面 资源加载器调用网络模块建立连接，发送请求，接收回复 资源加载器接收各种同步（异步）的网页/资源 网页交给HTML解释器进行解析：bytes -&gt; charaters -&gt; tokens -&gt; nodes -&gt; object model 遇到js标签，调用js引擎进行解释并执行，可能会修改DOM树结构 网页中依赖的js资源加载完成后，触发DomContentLoad事件 从DOM到屏幕 css文件下载后，webkit调用css解释器生成CSSOM，并在DOM树上附加样式信息，生成RenderObject树 webkit会根据网页的层次结构生成RenderLayer树，处理如z-index，浮动，定位等布局 浏览器将每个RenderLayer栅格化，独立绘制进位图，把这些位图作为纹理上传到GPU，复合多个层生成最终的屏幕图像 如有某些元素符合硬件渲染，webkit会创建GraphicsLayer，把它们的后端信息上传到GPU处理 webkit通过显卡把内容绘制到屏幕上，RenderLayer递归的绘制自己及子女，RenderObject则会按照背景和边框、浮动内容、内容区前景的顺序绘制自己 第一次绘制的绘制区域是可视区的大小，会触发first paint事件。这一过程不必等到整个HTML文档解析完毕之后才执行，first paint与DomContentLoad没有先后顺序 所有依赖资源加载完毕触发onLoad事件 在渲染完成后，由于动画、用户交互、图片、视频、音频加载完成，浏览器会重复执行渲染过程 四种树结构 树结构名称 具体作用 DOM树 html代码下载完后解析的结果，包含了所有HTML标签，包括display:none的隐藏标签，以及JS动态添加的元素 Render树 RenderObject组成的树结构，CSSOM生成后和DOM树合成的树结构，RenderObject和DOM结构的Node可视节点基本上是一对一的关系 RenderLayer树 由RenderLayer组成，RenderLayer和RenderObject是一对多的关系，主要负责网页的层次关系 GraphicsLayer树 由GraphicsLayer组成，GraphicsLayer和RenderLayer是一对多的关系，主要负责硬件渲染 四棵树的时间关系 浏览器下载完html后开始将其解析成DOM树，解析过程是深度遍历 在DOM树构建过程中，CSSOM树使用DOM节点的attach方法同步将CSS样式信息附加到DOM节点上形成Render树 创建Render树的同时，webkit会根据网页的层次结构创建RenderLayer树 如元素具有开启硬件加速的属性，webkit会为它创建GraphicsLayer，同时由于根元素也是GraphicsLayer，所以GraphicsLayer也构成一颗树的结构 DOM树改变后，webkit会重复以上渲染过程 延伸知识点当清楚webkit渲染原理，就可以针对性的提出优化建议： 减少HTML文档大小，减少页面加载过程中js文件对DOM树的修改，提升生成DOM树速度 从加载HTML文档到触发first paint事件，这段时间称为白屏时间，减少白屏时间，提升用户体验 尽可能使用硬件加速，提高页面性能","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"node异步编程 - Generator入门","date":"2017-01-22T01:57:33.000Z","path":"2017/01/22/server-node-yield/","text":"Generator概念Generator函数是ES6提供的一种异步编程解决方案，语法上与传统函数完全不同。从语法上，Generator函数是一个状态机，封装了多个内部状态。执行Generator函数会返回编历器对象，可以依次遍历Generator函数内部的所有状态。 Generator函数特征 function关键字与函数名之间有一个星号 函数体内部使用yeild语句，定义不同的内部状态 Generator函数执行过程 调用Generator函数，该函数并不执行，而是返回编历器对象 调用编历器对象的next方法，内部指针从函数头部或上一次停下来的地方开始执行 遇到下一个yeild语句（return语句），中断（停止）执行 yield语句 遇到yield语句，暂停执行，将紧跟在yield后面的表达式的值，作为返回的对象的value属性值 yeild*语句 在yeild命令后加上星号，表示返回的是一个遍历器对象 在Generator函数内部，调用另一个Generator函数，默认情况下是没有效果的，需要通过yeild*语句，实现在Generator函数内部调用另一个Generator函数 next方法 yield语句本身没有返回值，next方法可在带一个参数，作为上一个yeild语句的返回值 通过next方法的参数，可以在Generator函数运行过程中，从外部向内部注入值进行控制 简单的流程控制器123456789101112131415let helper = function(fn) &#123; return function() &#123; let args = [].slice.call(arguments); let pass; args.push(function() &#123; if (pass) &#123; pass.apply(null, arguments); &#125; &#125;); fn.apply(null, args); return function(fn) &#123; pass = fn; &#125;; &#125;;&#125;; 代码解析： 对异步方法进行封装，异步方法的调用与回调方法的定义可以分拆进行 12345678910111213141516171819202122232425let flow = function(gfn) &#123; let generator = gfn.apply(null, [].slice.call(arguments, 1)); let next = function() &#123; generator.ret = generator.next([].slice.call(arguments)); if (generator.ret.done) &#123; return; &#125; if (typeof generator.ret.value == 'function') &#123; generator.ret.value(function() &#123; let args = [].slice.call(arguments); if (args.length == 1 &amp;&amp; args[0] instanceof Array) &#123; args = args[0]; &#125; next.apply(null, args); &#125;); &#125; else &#123; let args = [].slice.call(arguments); if (args.length == 1 &amp;&amp; args[0] instanceof Array) &#123; args = args[0]; &#125; next.apply(null, args); &#125; &#125;; next();&#125;; 代码解析： 可以处理异步回调或非异步回调代码逻辑，如果是异步回调，在返回值的方法里执行next 通过next，把上一步yield执行结果交给下一步作为输入值，自动执行整个状态流程 遇到的坑 Generator函数只是语法上的解决方案，通过交出函数体的执行控制权实现同步的写法，但并没有改变js异步操作的根本实现，该需要异步回调方法的地方还是需要编写异步回调代码 参考文档 http://es6.ruanyifeng.com/#docs/generator","tags":[{"name":"服务端框架","slug":"服务端框架","permalink":"http://blog.smallpig.cn/tags/服务端框架/"}]},{"title":"Postman用法简介","date":"2017-01-05T01:38:29.000Z","path":"2017/01/05/front-postman/","text":"简介Postman是一款功能强大的用于发送HTTP请求的模拟工具 新增/编辑请求用例 操作步骤：1.选择请求的http协议2.填写请求链接（可以使用全局变量/环境变量填充）3.填写请求参数（键值对）4.点击send按钮，发送请求5.可以保存请求 编辑单个请求的测试用例 可以对单个请求结果编写测试用例 请求结果以responseBody字段返回 管理请求用例collection 请求用例collection可以分享，编辑，复制，删除，导出及增加文件夹管理 管理单个请求用例 单个请求用例可以编辑，复制及删除 管理环境变量 环境变量分全局环境变量及单个环境变量 可以通过环境变量区分开发环境，测试环境及生产环境 参考文档 https://www.getpostman.com/","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"CDN网络原理","date":"2016-12-29T02:24:35.000Z","path":"2016/12/29/front-cdn/","text":"CDN原理图 CDN解析过程 用户在浏览器输入域名(www.web.com)，浏览器发现本地没有DNS缓存，请求网站DNS服务器 网站的DNS服务域名解析设置CNAME记录，指向www.web.51cdn.com，请求指向智能DNS负载均衡系统 智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户 用户向该IP节点（CDN服务器）发出请求 由于是第一次访问，CDN服务器会向源web站点请求，缓存内容 把结果返回用户 CDN原理详解 每个CDN节点由两部分组成：负载均衡设备、高速缓存服务器 CDN网络在用户和服务器之间增加Cache层，通过接管DNS将用户的请求引导到Cache上获得源服务器的数据 负载均衡DNS通过预先定义好的策略，将当时最接近用户的节点地址提供给用户，使用户能够得到快速的服务 分布在世界各地的所有CDN节点保持通信，搜集各节点的通信状态，确保不将用户的请求分配到不可用的CDN节点上","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"github pages配置个性化域名","date":"2016-12-07T02:14:51.000Z","path":"2016/12/07/server-domain-config/","text":"域名解析常用的域名解析有 A记录 及 CNAME记录 两种，下面会分析一下这两种记录的各自用途 A记录 指定主机名（或域名）对应的IP地址记录 用户可以将该域名指向自己的服务器IP地址 CNAME记录 别名记录，允许您将多个名字映射到同一台计算机 优点：当多个域名需要指向同一服务器IP，可以将一个域名做A记录指向服务器IP，然后将其他域名做别名(CNAME)到A记录的域名上；当服务器IP地址变更时，不必对每一个域名做更改指向，只需要更改A记录的域名指向服务器新IP，其他别名（CNAME）的域名指向将自动更改到新的IP地址 如何给github pages配置独立域名github pages支持用户配置独立域名，结合CNAME记录就可以做到： 配置CNAME记录 登录域名服务后台（如万网），增加CNAME记录，指向[username].github.io username为你的github帐号名称，如我的是 firewood1122.github.io github仓库增加CNAME记录 在对应仓库增加CNAME文件，文件内容为个性化域名名称 提交CNAME文件到线上仓库 至此，你的github pages的个性化域已完成配置，可以访问了~~ 参考文档 https://help.github.com/articles/configuring-a-publishing-source-for-github-pages/","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"使用hexo搭建团队blog","date":"2016-11-29T11:37:18.000Z","path":"2016/11/29/server-hexo/","text":"Hexo简介Hexo是一个快速、简洁且高效的博客框架。 Hexo使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo1npm install -g hexo-cli Hexo建站123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install Hexo写作创建文档，然后使用Markdown语法编写1hexo new [layout] &lt;title&gt; Hexo部署这里采用ftp部署方式，更多部署方式可参考链接编辑_config.yml的deploy节点如下：123456deploy: type: ftpsync host: [ftp server host] user: [ftp account] pass: [ftp password] remote: [ftp folder path] host, user, pass, remote在配置ftp服务器后得到 Hexo发布12hexo generate #产出静态文件hexo deploy #发布 ftp服务搭建这里采用vsftpd搭建ftp服务器，centos可通过yum进行安装：1yum install vsftpd 创建ftp服务用户123adduser userName #增加用户passwd userName #设置用户密码usermod -a -G groupName userName #把用户加入某个用户组 配置vsftpdvsftpd的配置较多，具体可参考链接，但主要需要配置与权限相关的部份：1234567891011121314151617# 不允许匿名访问anonymous_enable=NO# 允许本地用户(即linux系统中的用户帐号)登录FTP服务器local_enable=YES# 用户登录FTP服务器后是否具有访问自己目录以外的其他文件的权限# 设置为YES时，用户被锁定在自己的home目录中，vsftpd将在下面chroot_list_file选项值的位置寻找chroot_list文件chroot_list_enable=YES# 被列入此文件的用户，在登录后将不能切换到自己目录以外的其他目录# 从而有利于FTP服务器的安全管理和隐私保护，此文件需自行建立chroot_list_file=/etc/vsftpd/chroot_list# 此项设为YES，user_list文件中的用户允许登录FTP服务器# 如果同时设置了userlist_deny=YES，则user_list文件中的用户将不允许登录FTP服务器userlist_enable=YES 配置nginx配置nginx，增加静态服务指向ftp目录，至此，访问nginx配置的url，就可以看到你刚刚搭建的团队blog了，开始来做团队技术文档的积累吧！ 参考文档 https://hexo.io/zh-cn/ http://os.51cto.com/art/201008/222036.htm","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"使用nginx实现PC端及移动端的页面跳转","date":"2016-11-24T08:53:38.000Z","path":"2016/11/24/server-nginx-redirect/","text":"使用场景业务需求：PC端及移动端共用相同的url，当访问设备为移动设备时，展示移动端页面，否则显示PC端页面。 解决这个需求可以有几种方案： 使用html5，css3实现响应式页面，但页面功能设计及实现成本较高，只能适用于较简单页面 使用javascript实现对应页面跳转，必须先固定访问某端页面，然后判断跳转，用户体验不好 使用nginx实现对应页面跳转，由服务端判断读取哪端页面，实现成本较低，用户体验好 如何使用nginx实现PC端及移动端的页面跳转？先来看下nginx如何配置：12345678910111213141516171819location / &#123; if ($http_user_agent ~* '^(MIDP)|(WAP)|(UP.Browser)|(Smartphone)|(Obigo)|(Mobile)|(AU.Browser)|(wxd.Mms)|(WxdB.Browser)|(CLDC)|(UP.Link)|(KM.Browser)|(UCWEB)|(SEMC\\\\-Browser)|(Mini)|(Symbian)|(Palm)|(Nokia)|(Panasonic)|(MOT\\\\-)|(SonyEricsson)|(NEC\\\\-)|(Alcatel)|(Ericsson)|(BENQ)|(BenQ)|(Amoisonic)|(Amoi\\\\-)|(Capitel)|(PHILIPS)|(SAMSUNG)|(Lenovo)|(Mitsu)|(Motorola)|(SHARP)|(WAPPER)|(LG\\\\-)|(LG/)|(EG900)|(CECT)|(Compal)|(kejian)|(Bird)|(BIRD)|(G900/V1.0)|(Arima)|(CTL)|(TDG)|(Daxian)|(DAXIAN)|(DBTEL)|(Eastcom)|(EASTCOM)|(PANTECH)|(Dopod)|(Haier)|(HAIER)|(KONKA)|(KEJIAN)|(LENOVO)|(Soutec)|(SOUTEC)|(SAGEM)|(SEC\\\\-)|(SED\\\\-)|(EMOL\\\\-)|(INNO55)|(ZTE)|(iPhone)|(Android)|(WindowsCE)|(Wget)|(Java)|(curl)|(Opera)$') &#123; rewrite '^/([0-9]+)/(.+)$' /skip/$1/m-$2; &#125; add_header Cache-Control no-cache; root ../html/; index index.html index.htm; error_page 404 http://www.baidu.com/;&#125;location /skip/ &#123; add_header Cache-Control no-cache; alias ../html/; index index.html index.htm; error_page 404 http://www.baidu.com/;&#125; 原理解析： 通过$http_user_agent判断访问设备是否属于移动端设备 当判断为移动端设备访问时，重写url（加上m-前辍），跳转到特定的目录/skip/ /skip/接收移动端页面访问请求，解析到对应的目录（当前例子中，PC端及移动端页面都放在同一目录下） 注意事项： 虽然例子中的页面是静态页面，但需要在nginx实现动态判断，建议设置页面不缓存 建议设置error_page，当对应端的页面不存在时，可以跳转到存在的页面，提升用户体验 location的设置与写的先后顺序无关 location的优先级判断 等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他匹配项 ^~类型表达式。一旦匹配成功，则不再查找其他匹配项 正则表达式类型（~ ~*）的优先级次之。如果有多个location的正则能匹配的话，则使用正则表达式最长的那个 常规字符串匹配类型，按前缀匹配 DEMO代码 https://github.com/firewood1122/code-sample/tree/master/projects/nginx","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"node.js的内存管理机制","date":"2016-11-08T11:30:25.000Z","path":"2016/11/08/server-node-mem/","text":"node.js的内存管理机制有什么特别？一般后端语言对于内存使用，不会有什么限制，通常是用尽所在服务器的物理内存，当没有可用内存后，抛出内存耗尽的错误。 但node.js不一样，node.js是使用v8引擎解析javascript，v8引擎设计是用于浏览器端的，对于一个浏览页面，v8引擎限制了最大可用内存，所以同理对于node.js，也是有最大可用内存限制，默认情况下并不能用光所在机器的物理内存。 为什么v8引擎需要限制使用内存v8引擎的内存回收会使javascript暂停执行，当管理内存越大，因为内存回收造成的停顿时间越长，应用的性能及响应能力会直线下降，所以限制使用内存是一个不错的选择。 可以打破这种限制吗？答案是可以的，node在启动时可以传递参数来调整内存限制的大小： node --max-old-space-size=1700 test.js // 单位为MB node --max-new-space-size=1024 test.js // 单位为KB v8引擎的内存分代从上面的设置参数，可能会有个疑问，为什么有两种参数设置？ 在v8中，主要把内存分为新生代及老生代两代，新生代是指存活时间较短的对象，老生代是指存活时间较长或常驻内存的对象。v8堆的大小是新生代的内存空间加上老生代的内存空间。 –max-old-space-size用于设置老生代内存限制–max-new-space-size用于设置新生代内存限制 老生代与新生代的默认内存大小机器位数 老生代 新生代 v8堆内存大小 32位 700M 16M 732M 64位 1400M 32M 1464M v8的内存回收机制新生代内存垃圾回收新生代中的对象主要通过Scavenge算法进行垃圾回收，Scavenge算法的具体实现中，主要采用了Cheney算法。 Cheney算法是一种采用复制方式进行垃圾回收的算法，它把堆内存分为两个空间，这两个空间有一个是使用状态，另一个是处于闲置状态。处于使用状态的空间称为From空间，处于闲置状态的称为To空间。 进程分配对象空间，首先分配到From空间，当触发垃圾回收时，会检查From空间里的对象是否存活，将活对象从From空间复制到To空间，当复制完成后，把From空间与To空间对调，完成一次新生代的内存垃圾回收。 Cheney算法的缺点是需要占用对等的内存空间完成复制动作，无法胜任大批量的内存管理，但用于新生代这种小量内存场景是很适合的。 老生代内存垃圾回收老生代对象是从新生代对象晋级来的，晋级的判断条件有两个： 是否经历过一次Scavenge垃圾回收，如果经历过，则复制到老生代内存空间 To空间是否使用率超过25%，如果超过25%，则复制到老生代内存空间（为什么限制25%，因为To空间会参与到后续的内存分配中，如果使用率过高，会影响内存分配） 老生代对象的内存回收方式： Mark-Sweep（标记清除） Mark-Compact（标记整理） Incremental Marking（增量标记） 标记清除：检查内存对象是否存活，如果已不存活，则清空对应占用空间，缺点是容易形成不连续的内存碎片空间，当需要给一个大对象分配空间时，可能无法完成分配。 标记整理：检查内存对象是否存活，如果已不存活，则清空对应占用空间，并把存活对象往一端移动，可以形成连续的内存空间用于内存分配，缺点是移动对象时为了保持应用与内存空间的一致性，需要进程全停顿，当整理内存较多时，应用等待时间较长。 增量标记：在标记整理的基础上，采用步进机制，把整个整理过程切分成多个小过程，应用停止一小段时间，同时完成一个小过程的垃圾回收，步进执行，直到执行完成整个整理过程，可以大大缩减全停顿的时间。 总结node.js的内存管理受制于v8引擎，触发垃圾回收，尤其是全堆回收，会大大影响进程的性能及响应能力，如果需要打造高性能的node.js应用，需要在内存使用上多加注意，尽量减少垃圾回收的动作。","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"http-proxy使用详解","date":"2016-11-02T01:36:12.000Z","path":"2016/11/02/server-http-proxy/","text":"使用场景现有A，B两个服务端，A是前端服务，B是后端服务，当A服务端遇到特定请求（如 /api）时，需转发到B服务端，有些人可能会提出可以前置nginx服务转发不同请求，但通常业务需要A服务端有鉴权功能，只有符合权根 的请求才能转发到B服务端，这就需要A服务端必须自身有转发功能了，下面就以 http-proxy 为例，看一下怎么在express中实现该场景功能。 express中间件代码123456789101112131415161718192021222324var httpProxy = require('http-proxy'), proxy = httpProxy.createProxy();module.exports = function(options) &#123; return function(req, res, next) &#123; // 构造GET请求参数 var query = []; for (var item in req.query) &#123; query.push(item + '=' + req.query[item]); &#125; // 构造代理服务路径 var reqOptions = &#123;&#125;; if (typeof options === 'string') &#123; reqOptions = &#123; target: options, ignorePath: true &#125;; reqOptions.target = reqOptions.target + req.path + '?' + query.join('&amp;'); &#125; console.log('ProxyUrl:' + reqOptions.target); proxy.web(req, res, reqOptions, function(err) &#123; err.mod = 'proxy'; next(err); &#125;); &#125;;&#125;; express中间件代码分析 实现了请求转发，核心代码是调用 proxy.web 把原请求转发出去 实现过程中发现get请求会丢失url后的请求参数，需重新构造完整的请求链接（PS：会不会更好的实现方式） 调用中间件代码app.use(&apos;/api&apos;, proxy(&apos;http://127.0.0.1:7778&apos;)); 在A服务端调用proxy代码，/api 的请求转发到B服务端 更多的用途 可以在转发前，对请求头进行修改 通过利用第三方插件，可以对响应进行修改 可以代理https，websocket 除了自身转发请求这种方式，http-proxy可以自身作为一个代理服务起来，相当于nginx的作用 DEMO代码 https://github.com/firewood1122/code-sample/tree/master/node.js/node-http-proxy 参考文档 https://github.com/nodejitsu/node-http-proxy","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"如何判断一个工具是否有用","date":"2016-10-18T01:40:58.000Z","path":"2016/10/18/job-tool-canuse/","text":"工具对于研发同学来说，可能是一个客户端工具（如svn，git），可能是一个框架（如spring，expressjs），可能是一个类库（如jQuery）。很多人都会有这种经历，依赖自己过往的经验，遴选适用于工作的工具，来协助自己更快更好的完成工作。 但往往遇到几个问题： 同类型的工具很多，应该选用哪一种？ 工具选择虽多，但都满足不了所有需求，总是缺少点什么东西？ 工具除了需要用到的部份，其他的部份显得有点多余臃肿。 面对这几个问题，有不同的做法： 选用其中一个工具，满足不了需求的部份通过人工补上 重造轮子，自制一个完全符合自身需求的 选用一个或多个，通过使用规范或自制的小工具把不同的工具贯通，使符合所有使用需求 怎样决策？ 只选用一种工具满足部份需求，这种方案最现成，但由于还存在不能满足的需求，使用起来，无论是客观上还是主观上，对于提升效率都有限 重造轮子，确实满足需求，但是重造轮子耗时较多，而且没经过业务使用，重造的轮子问题都会不少，最终能提升多少效率是个问号 我的做法： 选用一个或多个，通过使用规范或自制的小工具把不同的工具贯通，使符合所有使用需求 分析手头上的工具列表，了解哪个工具满足了什么需求 分析不同的工具是可以通过哪种方式贯通起来？使用规范还是自制小工具？ 基于分析结果制订规范或自制小工具 最后给出总体的使用规范 这样做的好处： 可以充分利用成熟工具，避免重造轮子遇到各种问题 可以满足所有需求，最大程度上提升效率 怎样熟悉一个工具： 查看官方文档，把新手指导和主要的功能（API）过一遍 按自己理解，把工具的功能实操一遍 把工具能用上的功能梳理成规范 对照自己的需求，对比出缺少的需求部份 不要轻易抱怨一个工具！一个工具是为了处理一些需求而产生的，这不见得能满足你的所有使用需求，但一个工具从诞生到成熟，是经历过业务使用的检验，踩过不少坑才能迭代出来的，短期内再造一个同样的轮子会困难重重，作为使用者，先要熟悉这个工具的内在价值，通过不同的方式组合使用，最大程度上发挥工具它自身的价值，才是正确的道路。","tags":[{"name":"工作心得","slug":"工作心得","permalink":"http://blog.smallpig.cn/tags/工作心得/"}]},{"title":"聊一聊javascript的传值方式","date":"2016-10-13T01:32:50.000Z","path":"2016/10/13/front-js-value/","text":"先看个典型的代码例子：1234567891011121314var a = 10;var b = &#123;test1: 1&#125;;var c = &#123;test2: 2&#125;;var test = function(a, b, c) &#123; a = 20; b = &#123;test1: 2&#125;; c.test2 = 3;&#125;;test(a, b, c);console.log(a);console.log(b);console.log(c); 想一想会输出怎样的结果？12310&#123;test1: 1&#125;&#123;test2: 3&#125; 常见的传值方式按值传递传递对象的值，实参与形参各占一份独立内存，相互不影响 按引用传递传递对象的引用，实参与形参共享一份内存，相互影响 Javascript的传值方式按共享传值 怎么理解按共享传值？ 对于基础类型，是按值传递，在方法内重新赋值，会指向新的内存 对于引用类型，在方法内重新赋值，会指向新的内存，如果修改对象内容，会影响实参的值 从上面的例子可以看出来，按共享传值是不同于按值传递，按引用传递的传值方式。 参考文档 http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"使用git进行代码管理","date":"2016-10-10T01:07:04.000Z","path":"2016/10/10/server-git-base/","text":"工作多年，用过不少代码管理工具，如Mercurial(hg)，svn，git等，在这么多的工具中，git是最近几年最火热的，也是主流在用的版本管理工具，趁着工作需要，狠狠熟悉了一把。 为什么使用git首先明确为什么使用git，一般的代码管理需求，使用svn也可以满足需求，在平时的实践中，git相比svn等传统的工具，最大的优势在于灵活的多分支管理。说到多分支管理，可能会有svn的资深使用者会说svn也能做到哇，是的，svn通过较复杂的模范和方式是可以达到类似的效果，但从使用的便捷性上来说，远远比不上git这种与生俱来的管理模式。 PS：本文不对如果使用git进行讨论，请各位看官提前了解git的基础用法。 git如何进行分支划分我们现在是按使用场景结合功能进行分支的规划管理： feature/版本号/功能块编号：某版本的功能块分支，通常针对某一独立功能点，开发完成后合并到开发主分支 dev/版本号：某版本的开发主分支 test/版本号：某版本的测试分支，通常是开发分支完成后，基于开发分支开出的独立分支，用于保持提测过程中代码不受干扰，确保开发与测试过程互不干扰 release/版本号：某版本的预发布分支，通常是测试通过后，基于测试分支开出的独立分支 hofix/版本号：某版本的紧急修复分支，通常是处理生产环境紧急问题，基于发布分支开出的独立分支 master：仓库主分支，某版本（包括紧急修复版本）上线后，把预发布版本合并进来 从以上分支规划可看出，对应不同的环节（功能点开发 -&gt; 开发集成自测 -&gt; 正式测试 -&gt; 发布上线 -&gt; 线上问题紧急修复），都有相对应的分支，互不干扰，确保了各种工作可以并行进行，在代码依赖这一块上 做到了解耦。 git分支管理 参考文档 http://www.oschina.net/translate/a-successful-git-branching-model","tags":[{"name":"基础工具","slug":"基础工具","permalink":"http://blog.smallpig.cn/tags/基础工具/"}]},{"title":"如何打造你的chrome扩展","date":"2016-09-05T08:42:00.000Z","path":"2016/09/05/front-chrome-extend/","text":"前端同学在工作中会使用到很多类型的chrome扩展（如JSONView，Postman等等），使用chrome扩展可以提升工作效率，不知道大家在使用别人制作的chrome扩展时，有没有想过也自己制作一个chrome扩展，满足自己在工作过程中的需求，下面会手把手的给大家讲述如果制作一个chrome扩展。 了解chrome扩展工程结构- manifest.json - index.html - index.js - background.js - makina-icon.png - makina-icon-128.png manifes.json：每一个扩展都有一个JSON格式的manifest文件，里面提供了该扩展的信息index.html：用于实现扩展的弹出页面index.js：扩展的content script脚本background.js：背景页js脚本，一般背景页不需要任何HTML，仅仅需要js文件*-icon.png：扩展不同尺寸的图标 配置manifest.json1234567891011121314151617181920212223242526272829&#123; \"name\": \"扩展名称\", \"version\": \"扩展版本\", \"manifest_version\": 2, \"description\": \"扩展描述\", \"icons\": &#123; \"48\": \"扩展小图标\", \"128\": \"扩展大图标\" &#125;, \"browser_action\": &#123; \"default_icon\": \"扩展在浏览器显示的默认图标\", \"default_title\": \"扩展标题\" &#125;, \"background\": &#123; \"scripts\": [\"背景.js\"] &#125;, \"permissions\": [ \"tabs\", \"background\", \"notifications\", \"http://*/*\" ], \"content_scripts\": [&#123; \"matches\": [\"http://*/*\", \"https://*/*\"], \"js\": [\"index.js\"] &#125;], \"offline_enabled\": true, \"content_security_policy\": \"script-src 'self' 'unsafe-eval'; object-src 'self'\"&#125; permissions：配置扩展的权限content_scripts：页面脚本offline_enabled：配置离线可继续使用扩展 背景页 扩展常常用一个单独的长时间运行的脚本来管理一些任务或者状态； 背景页是一个运行在扩展进程中的HTML页面。它在你的扩展的整个生命周期都存在； 同一时间只有一个实例处于活动状态； 一般情况下，背景页不需要任何HTML，仅仅需要js文件； 使用场景：在一个有背景页的典型扩展中，用户界面（比如，浏览器行为或者页面行为和任何选项页）是由沉默视图实现的。当视图需要一些状态，它从背景页获取该状态。当背景页发现了状态改变，它会通知视图进行更新。 常用权限配置 tabs：提供对chrome.tabs或chrome.windows模块的使用权限 background：使chrome在后台运行，直至用户退出浏览器 notifications：提供对 HTML notification API的使用权限 页面如何与content_scripts通信1234567891011// 页面代码：var customEvent = document.createEvent('Event');customEvent.initEvent('testEvent', true, true);this.target.setAttribute('data-test', '123');this.target.dispatchEvent(customEvent);// content_scripts代码：document.addEventListener('testEvent', function(e) &#123; var type = e.target.getAttribute('data-test'); console.log(type);&#125;); 原理：content_script与页面共享页面dom，可以通过自定义事件传递数据 content_scripts如何与背景页通信1234567891011121314// content_scripts代码：chrome.extension.sendRequest(&#123; actions: actions &#125;, function(response) &#123; if (response.code == 200) &#123; console.log(response); &#125;;&#125;);// 背景页代码：chrome.extension.onRequest.addListener(function(request, sender, sendResponse) &#123; if (request.actions) &#123; console.log(request.actions); &#125; sendResponse(&#123;code: 200&#125;);&#125;); 通过类似发送请求的方式进行通信，而且通信是双向的 与服务端接收请求不一样，处理逻辑是固定一个接收器，需自行写代码进行逻辑分发 参考文档 http://open.chrome.360.cn/extension_dev/overview.html","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"如何在node.js调用mysql","date":"2016-08-10T02:34:49.000Z","path":"2016/08/10/server-node-mysql/","text":"安装依赖包1npm install mysql 创建连接池12345678var mysql = require('mysql');var pool = mysql.createPool(config);config 参数：host: 数据库IP user: 数据库用户 password: 数据库密码database: 数据库名称 获取数据库连接12pool.getConnection(function(err, connection) &#123;&#125;); 查询表12345var sql = ['select * from', tName];connection.query(sql.join(' '), function(err, results, fields) &#123;&#125;);tName：表名 插入表123456var sql = ['insert into', tName, 'values?'].join(' ');connection.query(sql, [rows], function(err, results, fields) &#123;&#125;);tName：表名rows：数据列表 释放连接1connection.release();","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"如何安装使用redis","date":"2016-08-02T09:58:28.000Z","path":"2016/08/02/server-redis/","text":"官方下载http://download.redis.io/releases/ 安装步骤1make 运行方法12nohup ./src/redis-server &amp;默认端口：6379","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"移动端性能优化","date":"2016-07-06T03:17:02.000Z","path":"2016/07/06/front-base-wap/","text":"","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"持续集成-jenkins的安全策略","date":"2016-06-21T06:21:18.000Z","path":"2016/06/21/server-jenkins-safe/","text":"背景 项目数目趋向庞大，需要按不同业务划分，不同业务只能查看到自己可以操作的项目 避免项目过多，导致用户误操作 用户管理 以管理员帐号登录 打开 系统管理 - 管理用户 - 新建用户 新建用户 权限管理 以管理员帐号登录 打开 系统管理 - Configure Global Security 全局权限管理 推荐以项目矩阵授权策略进行管理 授与管理员所有权限 授与所有人员 Overall Read权限 项目权限管理 在项目配置页面，点击启用项目安全 授与人员对应的权限 注意事项 默认情况下，jenkins没有角色管理，需增加第三方组件才能进行角色管理 要授与所有人员 Overall Read权限，没有该权限，什么内容都看不到","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"node与文件操作","date":"2016-06-17T01:15:51.000Z","path":"2016/06/17/server-node-file/","text":"获取当前目录12__dirname：获取当前模块文件所在目录的完整绝对路径process.cwd()：获取当前进程的工作目录（执行时所在的目录） 文件路径API 引入依赖包 1var path = require('path') 获取绝对路径 1path.resolve(dirPath, fileName) 获取所在文件夹目录 1path.dirname(filePath) 获取相对路径 12path.relative(fromPath, toPath)获取从from到to的相对路径，可用于判断是否同一文件 拼接路径 1path.join(dirName, fileName) 获取规范化路径 12path.normalize(filePath)多个斜杠会被替换成一个；路径末尾的斜杠会被保留；Windows系统上, 会使用反斜杠 操作文件原生API 读文件（同步） 12fs.readFileSync('./.sync-ignore', 'utf8')如果指定字符集，返回字符串 读文件夹内容（同步） 12fs.readdirSync('.')返回文件名数组，其中不包括 '.' 和 '..' 目录 写文件（同步） 1fs.writeFileSync('./.sync-ignore', 'test', 'utf8') 删除文件（同步） 1fs.unlinkSync(deleteFilePath) 第三方库 获取文件MD5值 12var md5File = require('md5-file');var sMd5 = md5File.sync(source); 原生API扩展（迭代创建目录） 12var fs = require('fs-extra');fs.mkdirsSync(targetDir); 参考文档 https://nodejs.org/dist/latest-v4.x/docs/api/ https://www.npmjs.com/package/fs-extra","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"cookie的读与写","date":"2016-06-13T01:20:11.000Z","path":"2016/06/13/server-cookie/","text":"","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"跨时区与timestamp","date":"2016-06-13T01:07:41.000Z","path":"2016/06/13/front-js-timestamp/","text":"定义 时间戳（timestamp），通常是一个字符序列，唯一地标识某一刻的时间。 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。 误区时间戳是从格林威治时间1970年01月01日00时00分00秒起开始计算，同时对应到世界各地不同的开始时间，到现在的总秒数，所以在跨时区应用中不存在差异，不需要额外的计算。 如何获取时间戳 Linux：date +%s Js：(new Date()).getTime()","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"js获取GMT时区","date":"2016-05-24T01:18:55.000Z","path":"2016/05/24/front-js-utm/","text":"js代码12var date = new Date();var timezone = date.getTimezoneOffset() / 60; 代码说明 getTimezoneOffset()方法可返回格林威治时间和本地时间之间的时差，以分钟为单位 返回之所以以分钟计，而不是以小时计，原因是某些国家所占有的时区甚至不到一个小时的间隔 由于使用夏令时的惯例，该方法的返回值不是一个常量","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"css设置打印分页","date":"2016-05-10T12:55:47.000Z","path":"2016/05/10/front-css-print/","text":"如何打印特定区域内容html dom结构12345&lt;div id=\"div_print\"&gt; &lt;h1 style=\"color:red; page-break-after:always;\"&gt;The Div content which you want to print&lt;/h1&gt; &lt;h1 style=\"color:red;\"&gt;The Div content which you want to print&lt;/h1&gt; &lt;h1 style=\"color:red; page-break-before:always;\"&gt;The Div content which you want to print&lt;/h1&gt;&lt;/div&gt; 打印内容的javascript代码12345678910function printdiv(printpage) &#123; var headstr = \"&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\"; var footstr = \"&lt;/body&gt;\"; var newstr = document.all.item(printpage).innerHTML; var oldstr = document.body.innerHTML; document.body.innerHTML = headstr + newstr + footstr; window.print(); document.body.innerHTML = oldstr; return false;&#125; 触发打印操作的按钮1&lt;input name=\"b_print\" type=\"button\" class=\"ipt\" onClick=\"printdiv('div_print');\" value=\" Print \"&gt; 设置分页css说明 page-break-before：后置分页符 page-break-after：前置分页符 可以设置的值： auto 默认，如果必要则在元素后插入分页符。 always 在元素后插入分页符。 avoid 避免在元素后插入分页符。 left 在元素之后足够的分页符，一直到一张空白的左页为止。 right 在元素之后足够的分页符，一直到一张空白的右页为止。 inherit 规定应该从父元素继承 page-break-after 属性的设置。 参考文档 http://blog.csdn.net/savagelin/article/details/6589965","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"初探 ant design","date":"2016-05-05T03:45:39.000Z","path":"2016/05/05/front-ant-design/","text":"参考文档 http://ant.design/docs/spec/introduce https://segmentfault.com/a/1190000003789022?_ea=380891","tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.smallpig.cn/tags/前端框架/"}]},{"title":"持续集成-jenkins使用介绍","date":"2016-04-27T01:36:25.000Z","path":"2016/04/27/server-jenkins-start/","text":"持续集成与jenkins 持续集成是为了配合敏捷开发的速度和效率而产生的一个用于编译、测试、发布、部署的工具为什么叫持续呢？其实就是编码人员提交了源码，该工具就可以进行编译，测试等一系列运作Jenkins是基于Java开发的一种持续集成工具，用于监控持续重复的工作 下面就如何在jenkins上构建job，描述一下具体的流程： 创建构建job进入jenkins系统后，点击左上方的Jenkins菜单，选择新建： 填写构建配置 填写项目名称/描述： 填写保留构建配置，可选择填写保留天数/保留个数，以节省构建空间： 填写构建参数，参数可以输入框填写/下拉框选择/更多类型，主要用于编写构建脚本时使用： 填写构建前，对远程服务器的操作（创建远程服务器请参考下面部份）： Name：已创建的远程服务器名称Source files：源文件路径Remove prefix：源文件需去掉的前辍，去掉后作为放置在远程服务器的路径/名称Remote directory：远程服务器目录Exec command：在远程服务器上的执行命令 填写构建后，对远程服务器的操作： 编写构建脚本，可以使用构建参数/变量列表进行编写： 构建后操作，可用于定义存档文件 创建远程服务器 点击左上角jenkins菜单，进入系统管理 - 系统设置： 填写远程服务器信息： 总结 jenkins只是众多持续集成工具的其中一种，工具不重要，重要的是我们要具备持续集成的意识，利用工具自动化工作过程中的一些流程性/重复性工作，提高效率，提升自身的投入/产出比","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]},{"title":"解决chrome浏览器保存密码的问题","date":"2016-04-25T07:53:37.000Z","path":"2016/04/25/front-chrome-password/","text":"问题背景chrome浏览器，登录表单保存时，浏览器会弹出是否保存密码，如果选择保存密码，再次打开表单时，会默认填入保存的帐号密码，会导致页面交互出现问题。 解决方案解决方案很简单，在页面增加可见的类型为password的input，就可以解决默认填入保存的帐号密码的问题：1&lt;input type=\"password\" value=\"\" /&gt; 优化增加的input必须为可见的节点，不能使用 display: none 进行隐藏，可以使用绝对定位进行优化：1&lt;input type=\"password\" value=\"\" style=\"position:absolute; left:-99999px;\" /&gt;","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"本站导航","date":"2016-04-23T11:56:53.000Z","path":"2016/04/23/navigation/","text":"前端基础知识 解决chrome浏览器保存密码的问题 Chome浏览器Timeline工具的使用 facebook联合登录 移动端性能优化 CDN网络原理 WEBKIT渲染原理 css基础知识 解决logo图片在浏览器上模糊的问题 css设置打印分页 javascript基础知识 聊一聊javascript的传值方式 js获取GMT时区 跨时区与timestamp 解决跨域的cookie读写问题 cookie的读与写 利用canvas爬取网站图片 如何打造你的chrome扩展 React Native基础知识 React Native修改APP名称及图标 ui框架 Semantic - UI使用 初探 ant design javascript框架 ejs使用总结 node.js 创建&amp;发布npm包 npm使用总结 gulp使用教程 node.js的内存管理机制 node与文件操作 如何在node.js调用mysql http-proxy使用详解 node异步编程 - Generator入门 使用log4js记录nodejs服务日志 服务端基础知识 浅析HTTP协议 服务端框架 初始化express框架 服务端工具 nginx使用总结 使用nginx实现PC端及移动端的页面跳转 如何安装使用redis github pages配置独立域名 Postman用法简介 Linux下添加新分区及挂载 持续集成-jenkins使用介绍 持续集成-jenkins的安全策略 Docker-Docker简介 Docker-通过Docker Machine运行docker容器 自动化测试 自动化测试 - phantom.js 自动化测试 - page-monitor 自动化测试 - CasperJS 自动化测试 - Nightmare 支撑工具类 使用RAP模拟数据服务 使用git进行版本管理 Markdown语法简介 使用hexo搭建团队blog 工作心得 如何判断一个工具是否有用 研发流程中的项目管理/分支管理 通过选择商品sku查询对应库存","tags":[{"name":"工作心得","slug":"工作心得","permalink":"http://blog.smallpig.cn/tags/工作心得/"}]},{"title":"自动化测试-Nightmare","date":"2016-04-22T07:05:55.000Z","path":"2016/04/22/front-test-nightmare/","text":"参考文档 http://www.nightmarejs.org/","tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.smallpig.cn/tags/前端框架/"}]},{"title":"npm使用总结","date":"2016-04-22T07:00:30.000Z","path":"2016/04/22/server-node-npm/","text":"npm配置 设置淘宝镜像 1registry=https://registry.npm.taobao.org/ 设置npm翻墙 1npm config set https-proxy http://username:pawword@server:port 更新npm自身 1npm -g install npm@3.* 按版本号安装包 1npm install -g package@version 参考文档 http://my.oschina.net/deathdealer/blog/208919","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"自动化测试-CasperJS","date":"2016-04-20T01:37:09.000Z","path":"2016/04/20/front-test-casperjs/","text":"安装步骤 需安装phantom.js及python npm安装capserjs1npm install capserjs -g 运行命令 命令行运行1casperjs --ignore-ssl-errors=true app.js 配置参数 设置调试模式 12verbose: true,logLevel: 'debug' 处理中文乱码 1phantom.outputEncoding = 'GBK'; 设置超时时间 1waitTimeout: 5000 设置视窗大小 123pageSettings: &#123; viewportSize: &#123; width: 1920, height: 600 &#125;&#125; 模拟动作 鼠标点击1casper.mouse.move('#J_header_login_state .vhbm-account-btn i') PhantomCSS 设置快照保存目录 1screenshotRoot: './screenshots' 设置对比精细度 1mismatchTolerance: 0 设置差异展示样式 123456789outputSettings: &#123; errorColor: &#123; red: 255, green: 0, blue: 0 &#125;, errorType: 'movement', transparency: 0.3&#125; 对比所有快照 1phantomcss.compareAll() 对比特定快照 1phantomcss.compareFiles('./screenshots/start_0.diff.png', './screenshots/start_0.png') 参考文档 http://casperjs.org/ https://github.com/Huddle/PhantomCSS https://www.npmjs.com/package/phantomcss","tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.smallpig.cn/tags/前端框架/"}]},{"title":"自动化测试 - page-monitor","date":"2016-04-20T01:33:43.000Z","path":"2016/04/20/front-test-page-monitor/","text":"PMUI缺点 不能在界面触发重新生成对比结果 不能以版本为维度进行查看结果 如果尺寸较大，查看对比结果较不方便 基于phantom改造，对于js动态比较比较难用 调研结论 适用于静态页面对比 参考文档 https://github.com/fouber/page-monitor https://github.com/fouber/pmui","tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.smallpig.cn/tags/前端框架/"}]},{"title":"facebook联合登录","date":"2016-04-19T08:39:39.000Z","path":"2016/04/19/server-facebook/","text":"业务流程图 DEMO代码 https://github.com/firewood1122/code-sample/tree/master/projects/facebook 参考文档 https://developers.facebook.com/docs/javascript https://developers.facebook.com/docs/facebook-login/web","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"自动化测试 - phantom.js","date":"2016-04-17T13:09:21.000Z","path":"2016/04/17/server-node-phantom/","text":"测试初始化 引入phantom库 1var phantom = require('phantom'); 设置测试浏览器代理 1phantom.create(['--proxy=127.0.0.1:8888']) 设置忽略ssl错误 1--ignore-ssl-errors=yes 设置请求超时 1234page.setting('resourceTimeout', '3000');page.property('onResourceTimeout', function(requestData, networkRequest) &#123; console.log('请求超时：' + requestData.url);&#125;); 设置屏幕大小 1page.property('viewportSize', &#123;width: 1980, height: 768&#125;); 请求页面 请求某一页面 123page.open('http://www.sample.com').then(function(status) &#123; console.log('请求结果：' + status);&#125;); 保存页面为图片 1page.render('data/test.png'); 执行javascript 12345page.evaluate(function() &#123; return document.querySelector('.index-section-header h2').innerHTML;&#125;).then(function(html) &#123; console.log(html);&#125;); 退出phantom 1ph.exit(); 调研结论Phantom JS是一个服务器端的JavaScript API的WebKit，但如果需要开展前端自动化测试，还需要结合其他测试框架，才能更好的实现自动化测试的目标。 参考文档 https://github.com/amir20/phantomjs-node http://www.zhouhua.info/2014/03/19/phantomjs/ http://phantomjs.org/","tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.smallpig.cn/tags/前端框架/"}]},{"title":"利用canvas爬取网站图片","date":"2016-04-14T05:29:53.000Z","path":"2016/04/14/front-canvas/","text":"背景业务需要爬取其他网站图片作为参考，但一般的服务器端爬虫会给发现，进而给封堵，不能工作，为了解决这种问题，可以结合canvas进行破解 准备工作已通过爬虫抓取图片链接列表，并通过服务端接口可以获取 实现原理 注意事项 canvas需设置大小 服务器需设置允许跨域访问 DEMO代码 https://github.com/firewood1122/code-sample/tree/master/projects/crawler","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"工具网站列表","date":"2016-04-11T08:54:04.000Z","path":"2016/04/11/tools/","text":"工具平台 百度统计 百度云加速 微信公众平台 Pingdom PageSpeed LeanCloud 效率工具 日事清 Shadowsocks AlloyDesigner BeJSON 在线图片压缩 图标工场 在线信用卡号生成器及验证器 变量命名翻译 技术框架 ECMAScript 6入门 NPM PM2 Express ThinkJS React Native中文网 React Navigation 社区网站 Div.IO 掘金 奇舞团博客","tags":[{"name":"工作心得","slug":"工作心得","permalink":"http://blog.smallpig.cn/tags/工作心得/"}]},{"title":"gulp使用教程","date":"2016-04-08T01:33:42.000Z","path":"2016/04/08/front-gulp/","text":"初始化环境 安装gulp 1npm install gulp --save-dev 创建gulpfile 123var gulp = require('gulp');gulp.task('default', function() &#123;&#125;); 运行gulp 1gulp gulp语法 读取文件夹内容1gulp.src('src/css/**/*.css').pipe(destDir); If a “globstar” is alone in a path portion, then it matches zero or more directories and subdirectories searching for matches. It does not crawl symlinked directories. 输出到目标文件夹12345var destDir = gulp.dest('debug/css/');gulp.src('src/css/**/*.css').pipe(destDir);gulp.dest：定义目标文件夹pipe：通过管道输出 参考文档 https://github.com/lisposter/gulp-docs-zh-cn/blob/master/getting-started.md https://github.com/isaacs/node-glob","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"解决logo图片在浏览器上模糊的问题","date":"2016-04-06T08:51:04.000Z","path":"2016/04/06/front-logo/","text":"","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"ejs使用总结","date":"2016-04-06T08:46:03.000Z","path":"2016/04/06/front-ejs/","text":"参考文档 https://github.com/tj/ejs","tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.smallpig.cn/tags/前端框架/"}]},{"title":"通过选择商品sku查询对应库存","date":"2016-04-06T06:33:52.000Z","path":"2016/04/06/job-select-sku/","text":"","tags":[{"name":"工作心得","slug":"工作心得","permalink":"http://blog.smallpig.cn/tags/工作心得/"}]},{"title":"解决跨域的cookie读写问题","date":"2016-04-06T06:22:43.000Z","path":"2016/04/06/server-cookie-setting/","text":"服务端设置12Access-Control-Allow-Origin:http://a.com // 表示允许a.com下的跨域访问Access-Control-Allow-Credentials:true // 如服务端不设置响应头，响应会被忽略不可用 ajax设置 An object of fieldName-fieldValue pairs to set on the native XHR object. For example, you can use it to set withCredentials to true for cross-domain requests if needed. 1xhr.withCredentials = true // 发起请求时携带cookie","tags":[{"name":"基础知识","slug":"基础知识","permalink":"http://blog.smallpig.cn/tags/基础知识/"}]},{"title":"Markdown语法简介","date":"2016-04-06T06:19:38.000Z","path":"2016/04/06/server-markdown/","text":"参考文档 http://www.appinn.com/markdown/","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"Semantic-UI使用","date":"2016-04-05T03:02:50.000Z","path":"2016/04/05/front-semantic-ui/","text":"安装node安装gulp1npm install -g gulp 安装semantic123npm install semantic-ui --savecd semantic/gulp build 在html文件引用12&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"semantic/dist/semantic.min.css\"&gt;&lt;script src=\"semantic/dist/semantic.min.js\"&gt;&lt;/script&gt; 参考文档 http://semantic-ui.com/introduction/getting-started.html","tags":[{"name":"前端框架","slug":"前端框架","permalink":"http://blog.smallpig.cn/tags/前端框架/"}]},{"title":"初始化express框架","date":"2016-03-29T11:57:57.000Z","path":"2016/03/29/server-express-start/","text":"安装express1npm install express --save-dev 安装express-generator1npm install express-generator -g 初始化express框架代码12express myapp -e-e 代表使 ejs模板，默认是jade模板 安装依赖包1npm install 参考文档 http://www.expressjs.com.cn/starter/installing.html https://www.npmjs.com/package/express-generator","tags":[{"name":"服务端框架","slug":"服务端框架","permalink":"http://blog.smallpig.cn/tags/服务端框架/"}]},{"title":"使用RAP模拟数据服务","date":"2016-03-01T07:19:30.000Z","path":"2016/03/01/server-rap/","text":"前后端对接痛点 维护接口文档比较麻烦，不直观 转换，维护前端模拟数据耗时费力 接口文档修改未能及时反馈到前端模拟数据 RAP服务功能 后端录入接口格式 前端扩充接口对应模拟数据 结合接口格式及模拟数据，输出完整的模拟数据 RAP使用方法 按团队 -&gt; 产品线 -&gt; 项目 -&gt; 模块 -&gt; 页面 -&gt; 接口维度进行管理 后端录入请求参数列表，响应参数列表数据格式 前端录入模拟数据 RAP参考文档 https://github.com/thx/RAP/wiki/home_cn","tags":[{"name":"前端工具","slug":"前端工具","permalink":"http://blog.smallpig.cn/tags/前端工具/"}]},{"title":"nginx使用总结","date":"2016-02-26T09:42:12.000Z","path":"2016/02/26/server-nginx/","text":"安装依赖库1yum install pcre* 安装nginx1./configure --prefix=../nginx --with-http_ssl_module 详细配置 获取年/月/日/小时 123456if ($time_iso8601 ~ \"^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)T(\\d&#123;2&#125;)\") &#123; set $year $1; set $month $2; set $day $3; set $hour $4;&#125; 进行条件判断 123456set $loggable 1;if ($arg_intfid = '') &#123; set $loggable 0;&#125;arg_intfid：请求参数intfid 根据判断条件写log 1access_log logs/statistics/access.log main if=$loggable; 设置日志格式 1log_format main '$arg_tm,appid=$arg_appid&amp;type=$arg_type' 设置响应内容返回图片 1234location /log &#123; root html; try_files $uri /images/collect.gif;&#125; 设置proxy_pass 12345678location / &#123; proxy_pass http://127.0.0.1:8080/; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Cookie $http_cookie; client_max_body_size 1000m;&#125;","tags":[{"name":"服务端工具","slug":"服务端工具","permalink":"http://blog.smallpig.cn/tags/服务端工具/"}]}]